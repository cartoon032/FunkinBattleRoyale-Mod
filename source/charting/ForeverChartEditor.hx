package charting;

import lime.ui.FileDialogType;
import lime.ui.FileDialog;
import flixel.util.FlxAxes;
import tjson.Json;
import haxe.io.Bytes;
import charting.data.AbsoluteText;
import charting.data.BaseButton;
import flixel.FlxBasic;
import flixel.FlxCamera;
import flixel.FlxG;
import flixel.FlxObject;
import flixel.FlxSprite;
import flixel.addons.display.FlxBackdrop;
import flixel.addons.display.FlxGridOverlay;
import flixel.addons.display.FlxTiledSprite;
import flixel.addons.display.shapes.FlxShapeBox;
import flixel.addons.ui.FlxInputText;
import flixel.addons.ui.FlxUI;
import flixel.addons.ui.FlxUICheckBox;
import flixel.addons.ui.FlxUIDropDownMenu;
import flixel.addons.ui.FlxUIInputText;
import flixel.addons.ui.FlxUINumericStepper;
import flixel.addons.ui.FlxUITabMenu;
import flixel.graphics.FlxGraphic;
import flixel.group.FlxGroup;
import flixel.group.FlxSpriteGroup;
import flixel.math.FlxMath;
import flixel.system.FlxSound;
import flixel.text.FlxText;
import flixel.ui.FlxButton;
import flixel.util.FlxColor;
import flixel.util.FlxGradient;
import lime.media.AudioBuffer;
import openfl.events.Event;
import openfl.events.IOErrorEvent;
import openfl.geom.ColorTransform;
import openfl.geom.Rectangle;
import openfl.media.Sound;
import openfl.net.FileReference;
import openfl.utils.ByteArray;
import sys.FileSystem;
import sys.io.File;

import Song;

using StringTools;

#if sys
import sys.thread.Thread;
#end

/**
	Chart Editor ported directly from Forever Engine Underscore, with some adjustements so it actually runs on Super Engine

	Super, you should probably take a look at it since it has SEVERAL optimization issues and lacks must-have features
	I'm not the best programmer ever, but i hope this can be of some use.
	
	== CURRENT BUGS
	* Strumline Arrows aren't visible due to them having a spinning note for boyfriend
	* Note Placing crashes
	* a lot of other stuffs that i'm STILL looking through and fixing
	
	-gabi(ghost)
**/
class ForeverChartEditor extends MusicBeatState
{
	var _song:SwagSong;

	var _file:FileReference;

	var songMusic:FlxSound;
	var vocals:FlxSound;
	private var keysTotal = 8;

	var strumLine:FlxSprite;
	var strumGroup:FlxSpriteGroup;

	var camHUD:FlxCamera;
	var camGame:FlxCamera;
	var strumLineCam:FlxObject;

	public static var songPosition:Float = 0;
	public static var curSong:SwagSong;

	public static var gridSize:Int = 50;

	public var curSection:Null<Int> = 0;

	/**
	 * CURRENT / LAST PLACED NOTE;
	**/
	var curSelectedNote:Array<Dynamic>;

	var curNoteType:Int = 0;
	var tempBpm:Float = 0;

	var dummyArrow:FlxSprite;
	var notesGroup:FlxTypedGroup<Note>;
	var holdsGroup:FlxTypedGroup<FlxSprite>;
	var sectionsGroup:FlxTypedGroup<FlxBasic>;

	var iconL:HealthIcon;
	var iconR:HealthIcon;

	var markerL:FlxSprite;
	var markerR:FlxSprite;

	final markerColors:Array<FlxColor> = [
		FlxColor.RED, FlxColor.BLUE, FlxColor.PURPLE, FlxColor.YELLOW,
		FlxColor.GRAY, FlxColor.PINK, FlxColor.ORANGE, FlxColor.CYAN, FlxColor.GREEN,
		FlxColor.LIME, FlxColor.MAGENTA
	];
	var markerLevel:Int = 0;
	var scrollSpeed:Float = 0.75;
	
	final scrollArray:Array<Float> = [0.5, 0.75, 1, 1.05, 1.5, 2, 2.05, 2.5, 3, 3.05, 3.5];

	var arrowGroup:FlxTypedSpriteGroup<StrumArrow>;
	
	var buttonTextGroup:FlxTypedGroup<AbsoluteText>;
	var buttonGroup:FlxTypedGroup<ChartingButton>;
	
	var buttonArray:Array<Array<Dynamic>> = [];


	static var snapSound:Sound;
	static var clapSound:Sound;
	public static function playSnap(){
		if(snapSound == null)snapSound= Sound.fromFile('./assets/shared/sounds/SNAP.ogg');
		snapSound.play(new flash.media.SoundTransform(FlxG.save.data.hitvol));
	}
	public static function playClap(){
		if(clapSound == null)clapSound= Sound.fromFile('./assets/shared/sounds/CLAP.ogg');
		clapSound.play(new flash.media.SoundTransform(FlxG.save.data.hitvol));
	}
	public static function detectChartType(_song:SwagSong):String{
		if(_song.chartType != null && _song.chartType != "" && _song.chartType != "KE1"){
			return _song.chartType;
		}
		inline function isPsych():Bool{
			return _song.events != null;
		}
		inline function isKade():Bool{
			return _song.eventObjects != null || _song.chartType == "KE1";
		}
		if(isKade() && isPsych()){
			return _song.chartType = "KE/PSYCH HYBRID";
		}
		if(isKade()){
			return _song.chartType = "KADE";
		}
		if(isPsych()){
			return _song.chartType = "PSYCH";
		}
		if(_song.rawJSON != null && _song.rawJSON is String){
			var rawSong = Json.parse(_song.rawJSON);
			if(rawSong.generatedBy != null){
				return _song.chartType = 'Generated by ${rawSong.generatedBy}';
			}
		}

		return _song.chartType = "FNF/UNKNOWN";
	}

	override public function create()
	{
		super.create();
		TitleState.loadNoteAssets();

		generateBackground();
		ChartingState.charting = true;

		if (PlayState.SONG != null)
			_song = PlayState.SONG;
		else
			_song = Song.loadFromJson('test', 'test');
		_song.chartType = detectChartType(_song);
		loadSong(_song.song);
		Conductor.changeBPM(_song.bpm);
		Conductor.mapBPMChanges(_song);

		tempBpm = _song.bpm;

		generateGrid();

		notesGroup = new FlxTypedGroup<Note>();
		holdsGroup = new FlxTypedGroup<FlxSprite>();
		sectionsGroup = new FlxTypedGroup<FlxBasic>();
		buttonGroup = new FlxTypedGroup<ChartingButton>();
		buttonTextGroup = new FlxTypedGroup<AbsoluteText>();

		generateNotes();

		add(sectionsGroup);
		add(holdsGroup);
		add(notesGroup);
		add(buttonGroup);
		add(buttonTextGroup);

		generateButtons();

		strumLineCam = new FlxObject(0, 0);
		strumLineCam.screenCenter(X);

		// epic strum line
		strumGroup = new FlxSpriteGroup(0, 0);

		strumLine = new FlxSprite(0, 0).makeGraphic(Std.int(FlxG.width / 2), 2);
		strumGroup.add(strumLine);
		strumGroup.screenCenter(X);

		// add quant markers;
		markerL = new FlxSprite(-8, -12).loadGraphic(SELoader.loadGraphic('assets/shared/images/charter/marker.png'));
		markerR = new FlxSprite((FlxG.width / 2) - 8, -12).loadGraphic(SELoader.loadGraphic('assets/shared/images/charter/marker.png'));
		strumGroup.add(markerL);
		strumGroup.add(markerR);

		// add health icons;
		iconL = new HealthIcon(_song.player2, false);
		iconR = new HealthIcon(_song.player1, true);
		iconL.setGraphicSize(Std.int(iconL.width / 2));
		iconR.setGraphicSize(Std.int(iconR.width / 2));

		iconL.setPosition(-64, -128);
		iconR.setPosition(strumLine.width - 80, -128);

		strumGroup.add(iconL);
		strumGroup.add(iconR);

		// add icons, the strumline, and the quant markers;
		add(strumGroup);

		// cursor
		dummyArrow = new FlxSprite().makeGraphic(gridSize, gridSize);
		dummyArrow.alpha = 0.6;
		add(dummyArrow);

		// and now the epic note thingies
		arrowGroup = new FlxTypedSpriteGroup<StrumArrow>();
		for (i in 0...keysTotal)
		{
			var babyX = (FlxG.width / 2) - ((keysTotal / 2) * gridSize) + (i - 1) * gridSize;
			var newArrow:StrumArrow = new StrumArrow(i, babyX, strumLine.y);
			newArrow.init();

			newArrow.ID = i;
			newArrow.setGraphicSize(gridSize);
			newArrow.updateHitbox();
			newArrow.alpha = 0.9;
			newArrow.antialiasing = true;

			// lol silly idiot
			newArrow.playAnim('static');

			// those look kinda weird
			//arrowGroup.add(newArrow);
		}
		add(arrowGroup);
		arrowGroup.x -= 1;

		// code from the playstate so I can separate the camera and hud
		camGame = new FlxCamera();
		camHUD = new FlxCamera();
		camHUD.bgColor.alpha = 0;

		FlxG.cameras.reset(camGame);
		FlxG.cameras.add(camHUD, false);
		FlxG.cameras.setDefaultDrawTarget(camGame, true);

		FlxG.camera.follow(strumLineCam);

		generateHUD();

		FlxG.mouse.useSystemCursor = true; // Use system cursor because it's prettier
		FlxG.mouse.visible = true; // Hide mouse on start
		ChartingState.playClaps = true;
	}

	var songText:FlxText;
	var infoTextChart:FlxText;

	function generateHUD()
	{
		songText = new FlxText(0, 20, 0, "", 16);
		songText.setFormat(CoolUtil.font, 20, FlxColor.WHITE, LEFT);
		songText.scrollFactor.set();
		add(songText);

		songText.text = '${_song.song.toUpperCase()} <${CoolUtil.difficultyString()}>\n';

		var sidebar = new FlxShapeBox(916, 160, 326, 480, {thickness: 24, color: FlxColor.WHITE}, FlxColor.WHITE);
		sidebar.alpha = (26 / 255);
		sidebar.cameras = [camHUD];
		add(sidebar);

		// FlxG.height - 120

		var constTextSize:Int = 24;
		infoTextChart = new FlxText(5, FlxG.height - (constTextSize * 6), 0, 'TEST', constTextSize);
		infoTextChart.setFormat(CoolUtil.font, constTextSize);
		infoTextChart.cameras = [camHUD];
		add(infoTextChart);

		var ghostWatermark:FlxText = new FlxText(0, 0, 0, "", 16);
		ghostWatermark.setFormat(CoolUtil.font, 18, FlxColor.WHITE, LEFT);
		ghostWatermark.scrollFactor.set();
		add(ghostWatermark);

		ghostWatermark.text = 'Made by BeastlyGhost';
		ghostWatermark.setPosition(FlxG.width - (ghostWatermark.width + 5), FlxG.height - 30);
	}

	function updateHUD()
	{
		// update info text;
		infoTextChart.text = 'BEAT: ${FlxMath.roundDecimal(curBeat, 2)}'
			+ '\nSTEP: ${FlxMath.roundDecimal(curStep, 2)}'
			+ '\nTIME: ${FlxMath.roundDecimal(Conductor.songPosition / 1000, 2)} / ${FlxMath.roundDecimal(songMusic.length / 1000, 2)}'
			+ '\nBPM: ${_song.bpm}';

		// update markers if needed;
		markerL.color = markerColors[markerLevel];
		markerR.color = markerColors[markerLevel];
	}

	var hitSoundsPlayed:Array<Note> = [];

	override public function update(elapsed:Float)
	{
		if (FlxG.keys.justPressed.SPACE)
		{
			if (songMusic.playing)
			{
				songMusic.pause();
				vocals.pause();
				// playButtonAnimation('pause');
			}
			else
			{
				vocals.play();
				songMusic.play();

				// reset note tick sounds
				hitSoundsPlayed = [];

				// playButtonAnimation('play');
			}
		}

		if (!FlxG.keys.pressed.SHIFT)
		{
			if (FlxG.keys.pressed.W || FlxG.keys.pressed.S)
			{
				if (curStep <= 0)
					return;

				songMusic.pause();
				vocals.pause();

				var daTime:Float = 700 * FlxG.elapsed;

				if (FlxG.keys.pressed.W)
				{
					songMusic.time -= daTime;
				}
				else
					songMusic.time += daTime;

				vocals.time = songMusic.time;
			}
		}
		else
		{
			if (FlxG.keys.justPressed.W || FlxG.keys.justPressed.S)
			{
				if (curStep <= 0)
					return;

				songMusic.pause();
				vocals.pause();

				var daTime:Float = Conductor.stepCrochet * 2;

				if (FlxG.keys.justPressed.W)
				{
					songMusic.time -= daTime;
				}
				else
					songMusic.time += daTime;

				vocals.time = songMusic.time;
			}
		}

		if (FlxG.mouse.wheel != 0)
		{
			songMusic.pause();
			vocals.pause();

			songMusic.time = Math.max(songMusic.time - (FlxG.mouse.wheel * Conductor.stepCrochet * scrollSpeed), 0);
			songMusic.time = Math.min(songMusic.time, songMusic.length);
			vocals.time = songMusic.time;
		}
		
		if (FlxG.keys.justPressed.LEFT)
			changeMouseScroll(-1);
		if (FlxG.keys.justPressed.RIGHT)
			changeMouseScroll(1);

		// strumline camera stuffs!
		Conductor.songPosition = songMusic.time;

		strumGroup.y = getYfromStrum(Conductor.songPosition);
		strumLineCam.y = strumGroup.y + (FlxG.height / 3);
		arrowGroup.y = strumGroup.y;

		coolGradient.y = strumLineCam.y - (FlxG.height / 2);
		coolGrid.y = strumLineCam.y - (FlxG.height / 2);

		_song.bpm = tempBpm;

		super.update(elapsed);


		if (FlxG.mouse.x > (fullGrid.x)
			&& FlxG.mouse.x < (fullGrid.x + fullGrid.width)
			&& FlxG.mouse.y > 0
			&& FlxG.mouse.y < (getYfromStrum(songMusic.length)))
		{
			var fakeMouseX = FlxG.mouse.x - fullGrid.x;
			dummyArrow.x = (Math.floor((fakeMouseX) / gridSize) * gridSize) + fullGrid.x;
			if (FlxG.keys.pressed.SHIFT)
				dummyArrow.y = FlxG.mouse.y;
			else
				dummyArrow.y = Math.floor(FlxG.mouse.y / gridSize) * gridSize;

			// moved this in here for the sake of not dying
			if (FlxG.mouse.justPressed)
			{
				if (!FlxG.mouse.overlaps(notesGroup))
				{
					// add note funny
					var noteStrum = getStrumTime(dummyArrow.y);

					var notesSection = Math.floor(noteStrum / (Conductor.stepCrochet * 16));
					var noteData = adjustSide(Math.floor((dummyArrow.x - fullGrid.x) / gridSize), _song.notes[notesSection].mustHitSection);
					var noteSus = 0; // ninja you will NOT get away with this

					// noteCleanup(notesSection, noteStrum, noteData);
					// _song.notes[notesSection].sectionNotes.push([noteStrum, noteData, noteSus]);

					
					if (noteData > -1)
						generateChartNote(noteData, noteStrum, noteSus, 0, notesSection, true);
					// else
						// generateChartEvent(noteStrum, eValue1, eValue2, eName, true);
					
					// autosaveSong();
					// updateSelection(_song.notes[notesSection].sectionNotes[_song.notes[notesSection].sectionNotes.length - 1], notesSection, true);
					// isPlacing = true;
				}
				else
				{
					notesGroup.forEachAlive(function(note:Note)
					{
						if (FlxG.mouse.overlaps(note))
						{
							if (FlxG.keys.pressed.CONTROL)
							{
								// selectNote(note);
							}
							else
							{
								note.kill();
								notesGroup.remove(note);
								note.destroy();
							}
						}
					});
				}
			}
		}
		
		if (FlxG.mouse.justPressed)
		{
			if (FlxG.mouse.overlaps(buttonGroup))
			{
				buttonGroup.forEach(function(button:ChartingButton)
				{
					if (FlxG.mouse.overlaps(button))
					{
						button.onClick(null);
					}
				});
			}
		}

		if (FlxG.keys.pressed.CONTROL && FlxG.keys.justPressed.S)
		{
			// autosaveSong();
			saveLevel();
		}

		if (FlxG.keys.pressed.CONTROL && FlxG.keys.justPressed.L)
		{
			loadLevel_();
		}

		if (FlxG.keys.justPressed.ESCAPE)
		{
			// autosaveSong();
			songPosition = songMusic.time;
			PlayState.SONG = _song;
			FlxG.mouse.visible = false;
			songMusic.stop();
			vocals.stop();

			gotoPlaystate();
		}

		if (FlxG.keys.pressed.SHIFT && FlxG.keys.justPressed.ESCAPE)
		{
			// autosaveSong();
			FlxG.mouse.visible = false;
			songMusic.stop();
			vocals.stop();

			FlxG.switchState(new MainMenuState());
		}

		updateHUD();
	}
	
	function changeMouseScroll(newSpd:Int)
	{
		markerLevel += newSpd;
		if (markerLevel < 0)
			markerLevel = scrollArray.length - 1;
		if (markerLevel > scrollArray.length - 1)
			markerLevel = 0;

		scrollSpeed = scrollArray[markerLevel];
	}

	override public function stepHit()
	{
		super.stepHit();

		// call all rendered notes lol
		notesGroup.forEach(function(epicNote:Note)
		{
			if ((epicNote.y > (strumLineCam.y - (FlxG.height / 2) - epicNote.height))
				|| (epicNote.y < (strumLineCam.y + (FlxG.height / 2))))
			{
				epicNote.alive = true;
				epicNote.visible = true;
			}
			else
			{
				epicNote.alive = false;
				epicNote.visible = false;
			}
		});
	}

	override public function beatHit()
	{
		super.beatHit();
	}

	function getStrumTime(yPos:Float):Float
	{
		return FlxMath.remapToRange(yPos, 0, (songMusic.length / Conductor.stepCrochet) * gridSize, 0, songMusic.length);
	}

	function getYfromStrum(strumTime:Float):Float
	{
		return FlxMath.remapToRange(strumTime, 0, songMusic.length, 0, (songMusic.length / Conductor.stepCrochet) * gridSize);
	}

	var fullGrid:FlxTiledSprite;

	function generateGrid()
	{
		// create new sprite
		var base:FlxSprite = FlxGridOverlay.create(gridSize, gridSize, gridSize * 2, gridSize * 2, true, FlxColor.WHITE, FlxColor.BLACK);
		fullGrid = new FlxTiledSprite(null, gridSize * keysTotal, gridSize);
		// base graphic change data
		var newAlpha = (26 / 255);
		base.graphic.bitmap.colorTransform(base.graphic.bitmap.rect, new ColorTransform(1, 1, 1, newAlpha));
		fullGrid.loadGraphic(base.graphic);
		fullGrid.screenCenter(X);

		// fullgrid height
		fullGrid.height = (songMusic.length / Conductor.stepCrochet) * gridSize;
		add(fullGrid);
	}

	public var sectionLineGraphic:FlxGraphic;
	public var sectionCameraGraphic:FlxGraphic;
	public var sectionStepGraphic:FlxGraphic;

	private function regenerateSection(section:Int, placement:Float)
	{
		// this will be used to regenerate a box that shows what section the camera is focused on

		// oh and section information lol
		var sectionLine:FlxSprite = new FlxSprite(FlxG.width / 2 - (gridSize * (keysTotal / 2)) - (extraSize / 2), placement);
		sectionLine.frames = sectionLineGraphic.imageFrame;
		sectionLine.alpha = (88 / 255);

		// section camera
		var sectionExtend:Float = 0;
		if (_song.notes[section].mustHitSection)
			sectionExtend = (gridSize * (keysTotal / 2));

		var sectionCamera:FlxSprite = new FlxSprite(FlxG.width / 2 - (gridSize * (keysTotal / 2)) + (sectionExtend), placement);
		sectionCamera.frames = sectionCameraGraphic.imageFrame;
		sectionCamera.alpha = (88 / 255);
		sectionsGroup.add(sectionCamera);

		// set up section numbers
		for (i in 0...2)
		{
			var sectionNumber:FlxText = new FlxText(0, sectionLine.y - 12, 0, Std.string(section), 20);
			// set the x of the section number
			sectionNumber.x = sectionLine.x - sectionNumber.width - 5;
			if (i == 1)
				sectionNumber.x = sectionLine.x + sectionLine.width + 5;

			sectionNumber.setFormat(CoolUtil.font, 24, FlxColor.WHITE);
			sectionNumber.antialiasing = false;
			sectionNumber.alpha = sectionLine.alpha;
			sectionsGroup.add(sectionNumber);
		}

		for (i in 1...Std.int(_song.notes[section].lengthInSteps / 4))
		{
			// create a smaller section stepper
			var sectionStep:FlxSprite = new FlxSprite(FlxG.width / 2 - (gridSize * (keysTotal / 2)) - (extraSize / 2), placement + (i * (gridSize * 4)));
			sectionStep.frames = sectionStepGraphic.imageFrame;
			sectionStep.alpha = sectionLine.alpha;
			sectionsGroup.add(sectionStep);
		}

		sectionsGroup.add(sectionLine);
	}

	var sectionsMax = 0;

	function generateNotes()
	{
		// GENERATING THE GRID NOTES!
		notesGroup.clear();
		holdsGroup.clear();

		// sectionsMax = 1;
		generateSection();
		for (section in 0..._song.notes.length)
		{
			sectionsMax = section;
			curSection = section;
			regenerateSection(section, 16 * gridSize * section);
			setNewBPM(section);
			for (i in _song.notes[section].sectionNotes)
			{
				// note stuffs
				var daNoteType = i[3];
				generateChartNote(i[1], i[0], i[2], daNoteType, section, false);
			}
		}
		// lolll
		// sectionsMax--;
	}

	var extraSize = 6;

	function generateSection()
	{
		// pregenerate assets so it doesnt destroy your ram later
		sectionLineGraphic = FlxG.bitmap.create(gridSize * keysTotal + extraSize, 2, FlxColor.WHITE);
		sectionCameraGraphic = FlxG.bitmap.create(Std.int(gridSize * (keysTotal / 2)), 16 * gridSize, FlxColor.fromRGB(43, 116, 219));
		sectionStepGraphic = FlxG.bitmap.create(gridSize * keysTotal + extraSize, 1, FlxColor.WHITE);
	}

	function loadSong(daSong:String):Void
	{
		// if (FlxG.sound.music != null)
		// 	FlxG.sound.music.stop();
		// if (songMusic != null)
		// 	songMusic.stop();

		// if (vocals != null)
		// 	vocals.stop();

		// songMusic = new FlxSound();
		// vocals = new FlxSound();

		// songMusic.loadEmbedded(Sound.fromFile(if(onlinemod.OfflinePlayState.instFile != "") onlinemod.OfflinePlayState.instFile else 'assets/songs/' + _song.song.toLowerCase() + "/Inst.ogg"), false, true);
		
		// if (_song.needsVoices)
		// 	vocals = new FlxSound().loadEmbedded(Sound.fromFile(if(onlinemod.OfflinePlayState.voicesFile != "") onlinemod.OfflinePlayState.voicesFile else 'assets/songs/' + _song.song.toLowerCase() + "/Voices.ogg"), false, true);

		// // FlxG.sound.list.add(songMusic);
		// FlxG.sound.list.add(vocals);

		// songMusic.play();
		// vocals.play();

		// if (curSong == _song)
		// 	songMusic.time = songPosition;
		// curSong = _song;
		// songPosition = 0;

		// pauseMusic();
		if (FlxG.sound.music != null)
		{
			FlxG.sound.music.stop();
			// vocals.stop();
		}

		var loadedInst = Sound.fromFile(if(onlinemod.OfflinePlayState.instFile != "") onlinemod.OfflinePlayState.instFile else 'assets/songs/' + _song.song.toLowerCase() + "/Inst.ogg");
		FlxG.sound.playMusic(loadedInst, 0.6,true);
		songMusic = FlxG.sound.music;


		// WONT WORK FOR TUTORIAL OR TEST SONG!!! REDO LATER
		if(_song.needsVoices || (onlinemod.OfflinePlayState.voicesFile != "" && FileSystem.exists(onlinemod.OfflinePlayState.voicesFile))){
			vocals = new FlxSound().loadEmbedded(Sound.fromFile(if(onlinemod.OfflinePlayState.voicesFile != "")  onlinemod.OfflinePlayState.voicesFile else ('assets/songs/' + _song.song.toLowerCase() + "/Voices.ogg")));

		} 
		if(vocals == null){
			vocals = new FlxSound();
			_song.needsVoices = false;
		}

		FlxG.sound.list.add(vocals);
		pauseMusic();
		FlxG.sound.music.time = 0;
		vocals.time = 0;
		// FlxG.sound.music.pause();
		// vocals.pause();

		FlxG.sound.music.onComplete = function()
		{
			vocals.pause();
			FlxG.sound.music.pause();
			FlxG.sound.music.time = 0;
			vocals.time = 0;
			// pauseMusic();
		};
		// songMusic.onComplete = function()
		// {
		// 	songMusic.stop();
		// 	vocals.stop();
		// 	loadSong(daSong);
		// };
	}

	private function generateChartNote(daNoteInfo, daStrumTime, daSus, daNoteType:Dynamic, noteSection, pushNote:Bool)
	{

		var note:Note = new Note(daStrumTime, daNoteInfo, null, false, true,0);
		note.sustainLength = daSus;
		note.setGraphicSize(gridSize, gridSize);
		note.updateHitbox();

		note.screenCenter(FlxAxes.X);
		note.x -= ((gridSize * (keysTotal / 2)) - (gridSize / 2));
		note.x += Math.floor(adjustSide(daNoteInfo, _song.notes[noteSection].mustHitSection) * gridSize);

		note.y = Math.floor(getYfromStrum(daStrumTime));

		if (pushNote)
			_song.notes[noteSection].sectionNotes.push([daStrumTime, daNoteInfo % 8, daSus, '']);

		notesGroup.add(note);

		generateSustain(daStrumTime, daNoteInfo, daSus, daNoteType, note);

		note.mustPress = !_song.notes[curSection].mustHitSection;
		if (daNoteInfo > 3)
			note.mustPress = !note.mustPress;
	}

	private function generateSustain(daStrumTime:Float = 0, daNoteInfo:Int = 0, daSus:Float = 0, daNoteType, prevNote:Note)
	{
		// this is genuinely driving me insane and I don't know how should I do it
		if (daSus > 0 && prevNote != null)
		{
			/*
			var constSize = Std.int(gridSize / 2);

			var sustainVis:Note = ForeverAssets.generateArrow(_song.assetModifier, daStrumTime + Conductor.stepCrochet, daNoteInfo % 4, daNoteAlt, true,
				prevNote, daNoteType);
			sustainVis.setGraphicSize(constSize, Math.floor(FlxMath.remapToRange(daSus, 0, Conductor.stepCrochet * 16, 0, gridSize * constSize)));
			sustainVis.updateHitbox();
			sustainVis.x = prevNote.x + constSize;
			sustainVis.y = prevNote.y + constSize;
			holdsGroup.add(sustainVis);

			if (prevNote != null && prevNote.isSustainNote)
			{
				var sustainEnd:Note = ForeverAssets.generateArrow(_song.assetModifier, daStrumTime + Conductor.stepCrochet, daNoteInfo % 4, daNoteAlt, true,
					sustainVis, daNoteType);
				sustainEnd.setGraphicSize(constSize, Math.floor(FlxMath.remapToRange(daSus, 0, Conductor.stepCrochet * 16, 0, gridSize * constSize)));
				sustainEnd.updateHitbox();
				sustainEnd.x = sustainVis.x - 15;
				sustainEnd.y = sustainVis.y + (sustainVis.height) + (gridSize / 2);
				holdsGroup.add(sustainEnd);
			}
			*/
		}
	}

	var coolGrid:FlxBackdrop;
	var coolGradient:FlxSprite;

	private function generateBackground()
	{
		coolGrid = new FlxBackdrop(null, 1, 1, true, true, 1, 1);
		coolGrid.loadGraphic(SELoader.loadGraphic('assets/shared/images/charter/grid.png'));
		coolGrid.alpha = (32 / 255);
		add(coolGrid);

		// gradient
		coolGradient = FlxGradient.createGradientFlxSprite(FlxG.width, FlxG.height,
			FlxColor.gradient(FlxColor.fromRGB(188, 158, 255, 200), FlxColor.fromRGB(80, 12, 108, 255), 16));
		coolGradient.alpha = (32 / 255);
		add(coolGradient);
	}
	function generateButtons():Void
	{
		// x, y, text on button, text size, child (optional), size ("" (medium), "big", or "small"),
		// function that will be called when pressed (optional)

		buttonArray = [
			[FlxG.width - 350, 280, "SAVE SONG", 20, null, "medium", null],
			[FlxG.width - 350, 330, "RELOAD SONG", 20, null, "medium", null],
			//[FlxG.width - 350, 380, "LOAD AUTOSAVE", 20, null, "medium", null]
		];

		buttonGroup.clear();
		buttonTextGroup.clear();

		var void:Void->Void = null;

		for (i in buttonArray)
		{
			if (i != null)
			{
				// trace(i);

				switch (i[2].toLowerCase())
				{
					case 'reload song':
						void = function()
						{
							loadSong(PlayState.SONG.song);
							FlxG.resetState();
						};

					case 'save song':
						void = function()
						{
							saveLevel();
						}

					case 'load autosave':
						void = function()
						{
							PlayState.SONG = Song.parseJSONshit(FlxG.save.data.autosave);
							FlxG.resetState();
						}
					default:
						void = i[6];
				}

				var button:ChartingButton = new ChartingButton(i[0], i[1], i[5], null);
				button.child = i[4];
				button.clickThing = void;
				buttonGroup.add(button);

				var text:AbsoluteText = new AbsoluteText(i[2], i[3], button, 10, 10);
				text.scrollFactor.set();
				buttonTextGroup.add(text);
			}
		}
	}

	function adjustSide(noteData:Int, sectionTemp:Bool)
	{
		return (sectionTemp ? ((noteData + 4) % 8) : noteData);
	}

	function setNewBPM(section:Int)
	{
		if (_song.notes[curSection].changeBPM && _song.notes[curSection].bpm > 0)
		{
			Conductor.changeBPM(_song.notes[curSection].bpm);
		}
		else
		{
			// get last bpm
			var daBPM:Float = _song.bpm;
			for (i in 0...curSection)
				if (_song.notes[i].changeBPM)
					daBPM = _song.notes[i].bpm;
			Conductor.changeBPM(daBPM);
		}
	}

	function autosaveSong():Void
	{
		try{
			var json = {
				"song": _song
			};

			var data:String = Json.stringify(json, "\t");

			if ((data != null) && data.length > 0)
			{
				FlxG.save.data.autosave = data;
			}
			FlxG.save.flush();
		}catch(e){}
	}

	function loadAutosave():Void
	{
		try
		{
			PlayState.SONG = Song.parseJSONshit(FlxG.save.data.autosave);
			FlxG.resetState();
		}
		catch (e)
		{
			return;
		}
	}
	private function loadLevel_()
	{
		// var json:Dynamic = {
		// 	"song": _song
		// };
		try{

			trace("Load song...");

			{// Not copied from FunkinVortex, dunno what you mean
				fd = new FileDialog();
				fd.onSelect.add(function(path){
				// _file = new FileReference();
				// _file.addEventListener(Event.COMPLETE, onSaveComplete);
				// _file.addEventListener(Event.CANCEL, onSaveCancel);
				// _file.addEventListener(IOErrorEvent.IO_ERROR, onSaveError);
				// // Bodgey as hell but doesn't work otherwise
				// _file.save('{"song":' + data + "}", path);


					_song = Json.parse(sys.io.File.getContent(path));
					// updateGrid();
					showTempmessage('Loaded chart from ${path}');
				

				});
				fd.browse(FileDialogType.OPEN, 'json', null, "Load chart");
			}
		}catch(e){showTempmessage('Something error while saving chart: ${e.message}');}
	}
	// save things
	
	var fd:FileDialog;
	public static var lastPath:String;

	function saveLevel()
	{
		// var json:Dynamic = {
		// 	"song": _song
		// };
		try{

			trace("Saving song...");
			var _raw = _song.rawJSON;
			_song.rawJSON = null; // It's a good idea to not include 2 copies of the json
			var data:String = Json.encode(_song,"fancy",true);
			_song.rawJSON = _raw; // It's a good idea to not include 2 copies of the json
			if ((data != null) && (data.length > 0))
			{// Not copied from FunkinVortex, dunno what you mean
				fd = new FileDialog();
				fd.onSelect.add(function(path){
				// for (sid => section in swagShit.notes) { // Sort sections for the funni
				// 	if(section.sectionNotes == null || section.sectionNotes[0] == null) continue;
					
				// 	haxe.ds.ArraySort.sort(section.sectionNotes, function(a, b) {
				// 		if(a[0] < b[0]) return -1;
				// 		else if(b[0] > a[0]) return 1;
				// 		else return 0;
				// 	});

				// }
				try{
					//lastPath = path;
					onlinemod.OfflinePlayState.chartFile = path;}catch(e){return;}
					//Bodgey as hell but doesn't work otherwise
					sys.io.File.saveContent(path,'{"song":' + data + "}");
					showTempmessage('Saved chart to ${path}');
				

				});
				fd.browse(FileDialogType.SAVE, 'json', sys.FileSystem.absolutePath(lastPath), "Save chart");
			}
		}catch(e){showTempmessage('Something error while saving chart: ${e.message}');}
		//saveReminder.reset();
	}

	function onSaveComplete(_):Void
	{
		_file.removeEventListener(openfl.events.Event.COMPLETE, onSaveComplete);
		_file.removeEventListener(openfl.events.Event.CANCEL, onSaveCancel);
		_file.removeEventListener(IOErrorEvent.IO_ERROR, onSaveError);
		_file = null;
		FlxG.log.notice("Successfully saved LEVEL DATA.");
	}

	/**
	 * Called when the save file dialog is cancelled.
	 */
	function onSaveCancel(_):Void
	{
		_file.removeEventListener(openfl.events.Event.COMPLETE, onSaveComplete);
		_file.removeEventListener(openfl.events.Event.CANCEL, onSaveCancel);
		_file.removeEventListener(IOErrorEvent.IO_ERROR, onSaveError);
		_file = null;
	}

	/**
	 * Called if there is an error while saving the gameplay recording.
	 */
	function onSaveError(_):Void
	{
		_file.removeEventListener(openfl.events.Event.COMPLETE, onSaveComplete);
		_file.removeEventListener(openfl.events.Event.CANCEL, onSaveCancel);
		_file.removeEventListener(IOErrorEvent.IO_ERROR, onSaveError);
		_file = null;
		FlxG.log.error("Problem saving Level data");
	}

	function pauseMusic()
	{
		songMusic.time = Math.max(songMusic.time, 0);
		songMusic.time = Math.min(songMusic.time, songMusic.length);

		resyncVocals();
		songMusic.pause();
		vocals.pause();
	}

	function resyncVocals():Void
	{
		vocals.pause();

		songMusic.play();
		Conductor.songPosition = songMusic.time;
		vocals.time = Conductor.songPosition;
		vocals.play();
	}
	function gotoPlaystate(?jumpTo:Bool = false){
		ChartingState.charting = true;
		// saveReminder.cancel();
		// autosaveSong();
		if(jumpTo){
			PlayState.jumpTo = Conductor.songPosition;
		}
		switch(PlayState.stateType){
			case 2: LoadingState.loadAndSwitchState(new onlinemod.OfflinePlayState()); 
			case 4,6: LoadingState.loadAndSwitchState(new multi.MultiPlayState());
			case 5: LoadingState.loadAndSwitchState(new osu.OsuPlayState());
			default: LoadingState.loadAndSwitchState(new PlayState());
		}
	}
}